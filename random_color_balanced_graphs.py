# -*- coding: utf-8 -*-
"""Random_color_balanced_graphs.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sxl2EK3VsIrMLCRZUHzyyo24XTRNWcb9
"""
# %% imports
import numpy as np
import networkx as nx
import random
import graphs as gra
import warnings
warnings.filterwarnings("ignore")

# %% this code calculates the minimal number of balanced partitions, gg should be an nx.DiGraph
def FindMP(gg):
    gm = np.transpose(nx.adjacency_matrix(gg))
    network = gra.CoupledCellNetwork(gm.todense())
    grain = network.top_lattice_node() #most partitions
    return(len(set(grain[0]))), network, grain[0]

# %% function for liftting colors
def constrained_sum_sample_pos(n, total,more_than_2=None):
    """Return a randomly chosen list of n positive integers summing to a total.
    Each such list is equally likely to occur."""
    if more_than_2 != None:
        more_than_2 = np.asanyarray(more_than_2)
        reduce = more_than_2==True;
        test = (n-reduce.sum()) + 2*reduce.sum()
        if test>total:
            raise ValueError("Unable to duplicate nodes with selfloops. Increase number of total nodes.")
        dividers = sorted(random.sample(range(1, total-reduce.sum()), n - 1))
        D = [a - b for a, b in zip(dividers + [total-reduce.sum()], [0] + dividers)]
        idx = 0; counter = 0;
        for node_w_sloop in more_than_2:
            if node_w_sloop:
                if D[idx] == 1:
                    D[idx] = D[idx] + 1
                    counter = counter + 1
            idx = idx + 1
        if counter != reduce.sum():
            idx = np.random.randint(0,len(D))
            D[idx] = D[idx] + (abs(reduce.sum()-counter))
    else:
        dividers = sorted(random.sample(range(1, total), n - 1))
        D = [a - b for a, b in zip(dividers + [total], [0] + dividers)]
    
    return D
    #https://stackoverflow.com/questions/3589214/generate-random-numbers-summing-to-a-predefined-value

# %% creation of random base graph
def random_base(n_colors,P,N,B_selfloops,indegrees):
    
    check=0
    while check==0:
        B_mat = np.random.choice([True, False], size=(n_colors,n_colors), p=[P, 1-P])
        if B_selfloops==False:
            np.fill_diagonal(B_mat, False)
        
        # determine if random base graph has any nodes with zero in-degree, if so, add random edge
        if indegrees == True:
            zero_in = B_mat.sum(0) == 0;
            position=0;
            for state in zero_in:
                if state==True:
                    random_row_index = np.random.randint(0, n_colors)
                    if B_selfloops==False:
                        while random_row_index==position:
                            random_row_index = np.random.randint(0, n_colors)   
                    B_mat[random_row_index, position] = True
                position = position + 1
         
        # Determine if the number of fiber colors is equivalent to the one requested
        if n_colors==FindMP(nx.from_numpy_matrix(B_mat,create_using=nx.DiGraph))[0]:
            check=1
            colors=FindMP(nx.from_numpy_matrix(B_mat,create_using=nx.DiGraph))[2]
    
    return B_mat, colors

# %% creation of the liffted graph from base graph
def base_anthesis(Base_graph,blooming,N,n_colors,G_selfloops):

    check=0; counter=0
    while check==0:
        #used to call numpy.random.Generator.permuted
        rng = np.random.default_rng()
        #matrix populated by random liftting of base graph
        G_mat = np.zeros([N,N])
        #from the blooming array create an array with the indegrees for each node
        indegrees = np.hstack([np.asanyarray([i]*blooming[i]) for i in range(n_colors)])
        
        for i in range(n_colors):
          color_i_index = np.where(indegrees == i)[0]
          
        
          for j in range(n_colors):
            color_j_index = np.where(indegrees == j)[0]
            
            
            if Base_graph[i,j]:
              a = np.random.randint(2, size=color_i_index.size)#capped random amount of colored in-coming edges
        
              while np.sum(a,axis=None)==0:
                a = np.random.randint(2, size=color_i_index.size)
                 
              f = rng.permuted(np.stack([a for _ in range(color_j_index.size)], axis=1),axis=0);
              
              if i==j:
                  if G_selfloops==False:
                      # check if there are any selfloops within same color
                      if np.diag(f).sum()>0:
                          
                          # if same color nodes are fully connected: remove any selfloops
                          if (f.shape[0]-1)<=f.sum(0)[0]:
                              f = np.ones((f.shape[0],f.shape[0]))
                              np.fill_diagonal(f, 0)
                          else:
                              position=0
                              for state in np.diag(f):
                                  if state:
                                      zeros=np.where(f[:,position]==0)
                                      idx = random.choice(zeros[0][:])
                                      f[idx,position]=1
                                      f[position,position]=0
                                  position = position + 1
                                      
              G_mat[color_i_index.reshape([color_i_index.size,1]),color_j_index] = f.copy();
              
        colors=FindMP(nx.from_numpy_matrix(G_mat,create_using=nx.DiGraph))[2]
        # Determine if the number of fiber colors is equivalent to the one requested
        if n_colors==FindMP(nx.from_numpy_matrix(G_mat,create_using=nx.DiGraph))[0]:
            check=1
        counter = counter + 1
        if counter==20:
            break
    
    return G_mat, colors

# %%
def remove_ones(matrix, n):
    indices = np.where(matrix == 1)
    ones_count = len(indices[0])
    if n > ones_count:
        raise ValueError("Cannot remove more ones than present in the matrix.")
    random_indices = random.sample(range(ones_count), n)
    for i in random_indices:
        matrix[indices[0][i]][indices[1][i]] = 0
    return matrix